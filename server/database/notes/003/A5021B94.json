{
    "markdownValue": "\n```js\n//undefined数值环境当做NaN，null数值环境当做0;  boolean环境都是false\nvar c = undefined;\nc+2;//NaN\nvar b = null;\nb+2;//2\n\n```\n\n---\n\n\n##### Error异常捕获\n```js\n你可以用 throw 语句抛出一个异常并且用 try...catch 语句捕获处理它\n\n\ntry{\n    throw new Error('message')\n}cacth(e){\n    \n}finally{\n    \n}\n```\n\n---\n\n##### Promise\n![image](https://mdn.mozillademos.org/files/8633/promises.png)\n\n---\n\n##### async/await\n\n\n---\n\n\n##### 嵌套函数和闭包\n\n- 你可以在一个函数里面嵌套另外一个函数。嵌套（内部）函数对其容器（外部）函数是私有的。它自身也形成了一个闭包。一个闭包是一个可以自己拥有独立的环境与变量的的表达式（通常是函数）。\n\n- 既然嵌套函数是一个闭包，就意味着一个嵌套函数可以”继承“容器函数的参数和变量。换句话说，内部函数包含外部函数的作用域。\n\n> **可以总结如下：**\n\n- > 内部函数只可以在外部函数中访问。\n- > 内部函数形成了一个闭包：它可以访问外部函数的参数和变量，但是外部函数却不能使用它的参数和变量。\n\n> DEMO1\n\n```js\nfunction outside(x) {\n  function inside(y) {\n    return x + y;\n  }\n  return inside;\n}\nfn_inside1 = outside(3);\nfn_inside2 = outside(5);\n//注意此处调用时，x的值是如何被保存下来的\nfn_inside1(0); //3\nfn_inside2(0); //5\n\n```\n\n> DEMO2\n```js\nvar lst= []\nfor(var i=0;i<5;i++){\n lst.push((function(k){\n     return function(){\n        return k;\n     }\n })(i))\n}\n```\n\n\n---\n\n##### 关于对象\n\n> 对象的创建\n\n- 对象初始化器创建\n- 构造函数创建\n- Object.create()创建\n\n```js\n\n```\n\n> 对象的继承\n\n- 使用Object.create()创建的对象\n```js\nvar a = {a: 1}; \n// a ---> Object.prototype ---> null\n\nvar b = Object.create(a);\n// b ---> a ---> Object.prototype ---> null\nconsole.log(b.a); // 1 (继承而来)\n\nvar c = Object.create(b);\n// c ---> b ---> a ---> Object.prototype ---> null\n\nvar d = Object.create(null);\n// d ---> null\nconsole.log(d.hasOwnProperty); // undefined, 因为d没有继承Object.prototype\n\n\n```\n\n```js\n- 寻找属性，并且不会遍历原型链方法\n    1.obj.hasOwnProperty('key')\n    2.Object.keys('obj')\n```",
    "render": "<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-comment\">//undefined数值环境当做NaN，null数值环境当做0;  boolean环境都是false</span>\n<span class=\"hljs-keyword\">var</span> c = <span class=\"hljs-literal\">undefined</span>;\nc+<span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//NaN</span>\n<span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-literal\">null</span>;\nb+<span class=\"hljs-number\">2</span>;<span class=\"hljs-comment\">//2</span>\n\n</code></div></pre>\n<hr />\n<h5><a id=\"Error_13\"></a>Error异常捕获</h5>\n<pre><div class=\"hljs\"><code class=\"lang-js\">你可以用 <span class=\"hljs-keyword\">throw</span> 语句抛出一个异常并且用 <span class=\"hljs-keyword\">try</span>...catch 语句捕获处理它\n\n\n<span class=\"hljs-keyword\">try</span>{\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'message'</span>)\n}cacth(e){\n    \n}<span class=\"hljs-keyword\">finally</span>{\n    \n}\n</code></div></pre>\n<hr />\n<h5><a id=\"Promise_29\"></a>Promise</h5>\n<p><img src=\"https://mdn.mozillademos.org/files/8633/promises.png\" alt=\"image\" /></p>\n<hr />\n<h5><a id=\"asyncawait_34\"></a>async/await</h5>\n<hr />\n<h5><a id=\"_40\"></a>嵌套函数和闭包</h5>\n<ul>\n<li>\n<p>你可以在一个函数里面嵌套另外一个函数。嵌套（内部）函数对其容器（外部）函数是私有的。它自身也形成了一个闭包。一个闭包是一个可以自己拥有独立的环境与变量的的表达式（通常是函数）。</p>\n</li>\n<li>\n<p>既然嵌套函数是一个闭包，就意味着一个嵌套函数可以”继承“容器函数的参数和变量。换句话说，内部函数包含外部函数的作用域。</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>可以总结如下：</strong></p>\n</blockquote>\n<ul>\n<li>\n<blockquote>\n<p>内部函数只可以在外部函数中访问。</p>\n</blockquote>\n</li>\n<li>\n<blockquote>\n<p>内部函数形成了一个闭包：它可以访问外部函数的参数和变量，但是外部函数却不能使用它的参数和变量。</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>DEMO1</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">outside</span>(<span class=\"hljs-params\">x</span>) </span>{\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">inside</span>(<span class=\"hljs-params\">y</span>) </span>{\n    <span class=\"hljs-keyword\">return</span> x + y;\n  }\n  <span class=\"hljs-keyword\">return</span> inside;\n}\nfn_inside1 = outside(<span class=\"hljs-number\">3</span>);\nfn_inside2 = outside(<span class=\"hljs-number\">5</span>);\n<span class=\"hljs-comment\">//注意此处调用时，x的值是如何被保存下来的</span>\nfn_inside1(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">//3</span>\nfn_inside2(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">//5</span>\n\n</code></div></pre>\n<blockquote>\n<p>DEMO2</p>\n</blockquote>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> lst= []\n<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">5</span>;i++){\n lst.push((<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">k</span>)</span>{\n     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n        <span class=\"hljs-keyword\">return</span> k;\n     }\n })(i))\n}\n</code></div></pre>\n<hr />\n<h5><a id=\"_83\"></a>关于对象</h5>\n<blockquote>\n<p>对象的创建</p>\n</blockquote>\n<ul>\n<li>对象初始化器创建</li>\n<li>构造函数创建</li>\n<li>Object.create()创建</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-js\">\n</code></div></pre>\n<blockquote>\n<p>对象的继承</p>\n</blockquote>\n<ul>\n<li>使用Object.create()创建的对象</li>\n</ul>\n<pre><div class=\"hljs\"><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> a = {<span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>}; \n<span class=\"hljs-comment\">// a ---&gt; Object.prototype ---&gt; null</span>\n\n<span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-built_in\">Object</span>.create(a);\n<span class=\"hljs-comment\">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span>\n<span class=\"hljs-built_in\">console</span>.log(b.a); <span class=\"hljs-comment\">// 1 (继承而来)</span>\n\n<span class=\"hljs-keyword\">var</span> c = <span class=\"hljs-built_in\">Object</span>.create(b);\n<span class=\"hljs-comment\">// c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; null</span>\n\n<span class=\"hljs-keyword\">var</span> d = <span class=\"hljs-built_in\">Object</span>.create(<span class=\"hljs-literal\">null</span>);\n<span class=\"hljs-comment\">// d ---&gt; null</span>\n<span class=\"hljs-built_in\">console</span>.log(d.hasOwnProperty); <span class=\"hljs-comment\">// undefined, 因为d没有继承Object.prototype</span>\n\n\n</code></div></pre>\n<pre><div class=\"hljs\"><code class=\"lang-js\">- 寻找属性，并且不会遍历原型链方法\n    <span class=\"hljs-number\">1.</span>obj.hasOwnProperty(<span class=\"hljs-string\">'key'</span>)\n    <span class=\"hljs-number\">2.</span><span class=\"hljs-built_in\">Object</span>.keys(<span class=\"hljs-string\">'obj'</span>)\n</code></div></pre>\n",
    "url": "/notes/003/A5021B94"
}