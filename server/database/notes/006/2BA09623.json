{
    "markdownValue": "Vue插件\n-----\n\n### 1、概述\n\n简单来说，插件就是指对Vue的功能的增强或补充。\n\n比如说，让你在每个单页面的组件里，都可以调用某个方法，或者共享使用某个变量，或者在某个方法之前执行一段代码等\n\n### 2、使用方法\n\n总体流程应该是：\n\n【声明插件】——【写插件】——【注册插件】——【使用插件】\n\n写插件和声明插件是同步的，然后注册到Vue对象中（不用担心重复注册），最后在写Vue组件的时候使用写的插件\n\n#### **声明插件**\n\n先写一个js文件，这个js文件就是插件文件，里面的基本内容如下：\n\n    /*   说明：\n     *   插件文件：service.js\n     *   作者：王冬   QQ：20004604\n     * */\n    export default {\n        install: function (Vue, options) {\n            // 添加的内容写在这个函数里面\n        }\n    };\n\n其中install的第一个参数Vue表示的是Vue的实例，第二个参数表示的是一些设置选项。\n\nVue实例好理解，就是Vue对象。\n\n而options设置选项就是指，在调用这个插件时，可以传一个对象。\n\n例如这个对象有一个属性float，然后在写插件的一个方法/变量时，我需要输出一个数字，然后写一个if判断语句，\n\n假如options.float为true时，输出浮点数；\n\n假如为false或undefined（即没传参）时，输出为整数。\n\n具体怎么添加，之后再说。\n\n#### **注册插件**\n\n如果使用过Vue-router，就很好理解，通过import引入后，然后通过 `Vue.use(插件名)` 注册插件；\n\n例如，我们通常在main.js里引入各种东西，并且组件的根实例也在这里\n\n    //main.js\n    import Vue from 'vue'\n    import App from './App.vue'\n    \n    //关键是这两行\n    import service from './service.js'\n    Vue.use(service)\n    \n    new Vue({\n        el: '#app',\n        render: (h) => h(App)\n    })\n\n如代码中注释所说，关键是通过import导入service文件，然后在创建根组件之前，让Vue对象通过use方法来注册插件service。\n\n通过这样简单的两步，就可以使用插件了。\n\n### 3、写插件、使用插件\n\n按照官方文档，写插件有四种方法，先给出官方的代码：\n\n    //以下内容都是添加到上面install的函数里面的\n    \n    // 1. 添加全局方法或属性\n    Vue.myGlobalMethod = function () {\n        // 逻辑...\n    }\n    // 2. 添加全局资源\n    Vue.directive('my-directive', {\n        bind (el, binding, vnode, oldVnode) {\n            // 逻辑...\n        }\n        ...\n    })\n    // 3. 注入组件\n    Vue.mixin({\n        created: function () {\n            // 逻辑...\n        }\n        ...\n    })\n    // 4. 添加实例方法\n    Vue.prototype.$myMethod = function (options) {\n        // 逻辑...\n    }\n\n先给出最常用的：【4\\. 添加实例方法】的写法和使用方法\n\n#### **3.1【添加实例方法或属性】**\n\n1、核心思想：\n\n    通过prototype来添加方法和属性。\n    \n\n2、写：\n\n    //让输出的数字翻倍，如果不是数字或者不能隐式转换为数字，则输出null\n    Vue.prototype.doubleNumber = function (val) {\n        if (typeof val === 'number') {\n            return val * 2;\n        } else if (!isNaN(Number(val))) {\n            return Number(val) * 2;\n        } else {\n            return null\n        }\n    }\n    \n\n3、用：\n\n假设有这样一个组件：\n\n    <template>\n        <div>\n            {{num}}\n            <button @click=\"double\">点击后让左边的数字翻倍</button>\n        </div>\n    </template>\n    <script>\n        export default{\n            data(){\n                return {\n                    num: 1\n                }\n            },\n            methods: {\n                double: function () {\n                    //这里的this.doubleNumber()方法就是上面写的组件里的方法\n                    this.num = this.doubleNumber(this.num);\n                }\n            }\n        }\n    </script>\n\n我们便可以通过点击button按钮，让num的值，在每次点击都翻倍了。\n\n4、假如添加的是属性：\n\n例如：\n\n    Vue.prototype.number = 1;\n    \n\n会发生什么事情呢？\n\n    1、不管是【按值传递类型】还是【按引用传递类型】，该变量都不会被不同组件所共享，更准确的说，假如有A、B两个组件。A组件里的number数值改变，B组件里的number数值是不会跟着改变的。因此不要想着引用这样一个变量，然后修改了A中的值，B里也自动跟着改变了；\n    2、当组件里没有该属性时，调用时，显示的是通过插件获取的值；\n       当组件里有该属性时，调用时，显示的是组件里该属性的值；\n       由此而推，函数也是这样的，组件里的同名函数总是会覆盖插件提供的函数。\n       \n\n也就是说，当插件提供一个属性时，组件里没这个属性，就用插件的属性；组件有，就用组件自己的。\n\n#### **3.2【添加全局方法或属性】**\n\n1、核心思想：\n\n就是给Vue对象添加一个属性。\n\n初次接触很容易和上面3.1弄混，实际上，3.1是给组件里使用的，而3.2是给Vue对象使用的。\n\n例如，假如添加一个方法test()，那么：\n\n    通过3.1添加，是在组件里，通过this.test()来调用\n    \n    通过3.2添加，是在外面，通过Vue实例，如Vue.test()来调用\n    \n\n2、写：\n\n    //放在哪里参考上面\n    Vue.test = function () {\n        alert(\"123\")\n    }\n\n3、用：\n\n    //注意先导入Vue对象才能使用\n    Vue.test()\n\n使用时会执行对应的方法，比如这里就是alert弹窗\n\n4、其他：\n\n别问我如果和Vue本身属性同名会发生什么事情，我没试过=.=\n\n#### **3.3【注入组件】**\n\n1、核心思想：\n\n就像写Vue组件时，那样写，方法名保持一致，其会在执行组件对应的方法名之前执行。\n\n2、写：\n\n例如：\n\n    Vue.mixin({\n        created: function () {\n            console.log(\"组件开始加载\")\n        }\n    })\n\n然后这里的代码会在每个组件（包括根组件）的created执行之前执行。\n\n可以自行在每个组件的created方法里写一段console.log来查看测试\n\n可以和【实例属性】配合使用，用于调试或者控制某些功能\n\n    // 注入组件\n    Vue.mixin({\n        created: function () {\n            if (this.NOTICE)\n                console.log(\"组件开始加载\")\n        }\n    })\n    // 添加注入组件时，是否利用console.log来通知的判断条件\n    Vue.prototype.NOTICE = false;\n\n【注入给非Vue实例本身就有的方法】：\n\n假如是写给例如methods属性的某个方法，例如以下注入：\n\n    Vue.mixin({\n        methods: {\n            test: function () {\n                console.log(\"mixin test\");\n            }\n        }\n    })\n\n那么，组件里若本身有test方法，并 **不会** 先执行插件的test方法，再执行组件的test方法。\n\n而是只执行其中一个，并且优先执行组件本身的同名方法。这点需要注意\n\n3、用：\n\n不需要手动调用，在执行对应的方法时会被自动调用的（并且先调用插件里的，再调用组件本身的）\n\n4、其他：\n\n    1、如果同时有多个插件注入一个方法（例如created，那么会先执行先注入的那个方法，再依次执行后注入的，最后执行组件本身的）\n    2、注意，像methods属性下的方法，并不会在组件注入后每个都执行，而是只执行一个，并且优先执行组件本身的。\n    \n    \n\n#### **3.4【添加全局资源】**\n\n1、核心思想：\n\n添加方法和正常添加方法类似，甚至几乎一样。\n\n可以添加【自定义指令】、【过滤器】、【过渡等】，这里以【过滤器】为例\n\n2、写：\n\n例如：\n\n    //时间格式化过滤器，输入内容是number或者Date对象，输出是YYYY-MM-DD HH-MM-SS\n    Vue.filter('formatTime', function (value) {\n        Date.prototype.Format = function (fmt) { //author: meizz\n            var o = {\n                \"M+\": this.getMonth() + 1, //月份\n                \"d+\": this.getDate(), //日\n                \"h+\": this.getHours(), //小时\n                \"m+\": this.getMinutes(), //分\n                \"s+\": this.getSeconds(), //秒\n                \"q+\": Math.floor((this.getMonth() + 3) / 3), //季度\n                \"S\": this.getMilliseconds() //毫秒\n            };\n            if (/(y+)/.test(fmt))\n                fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n            for (var k in o)\n                if (new RegExp(\"(\" + k + \")\").test(fmt))\n                    fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length)));\n            return fmt;\n        }\n        return new Date(value).Format(\"yyyy-MM-dd hh:mm:ss\");\n    })\n\n3、用：\n\n和正常使用一样用就行了，so easy。例如：\n\n    {{num|formatTime}}\n\n4、其他：\n\n可以用这个找各种有意思的功能，作为插件写好，然后需要的地方导入就行，超级方便！\n\n### 4、示例demo\n\n附一个有简单功能的示例demo，提供参考使用\n\n    /*  说明：\n     *  插件demo，供学习使用\n     *  本页面用于提供各种处理服务\n     *  作者：王冬   QQ：20004604\n     *  功能有：\n     *  1、插件created执行时提示；\n     *  2、\n     * */\n    export default {\n        install: function (Vue, options) {\n            // 1. 添加全局方法或属性\n            // 略\n    \n            // 2. 添加全局资源\n            //  时间格式化过滤器，输入内容是number或者Date对象，输出是YYYY-MM-DD HH-MM-SS\n            Vue.filter('formatTime', function (value) {\n                Date.prototype.Format = function (fmt) { //author: meizz\n                    var o = {\n                        \"M+\": this.getMonth() + 1, //月份\n                        \"d+\": this.getDate(), //日\n                        \"h+\": this.getHours(), //小时\n                        \"m+\": this.getMinutes(), //分\n                        \"s+\": this.getSeconds(), //秒\n                        \"q+\": Math.floor((this.getMonth() + 3) / 3), //季度\n                        \"S\": this.getMilliseconds() //毫秒\n                    };\n                    if (/(y+)/.test(fmt))\n                        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n                    for (var k in o)\n                        if (new RegExp(\"(\" + k + \")\").test(fmt))\n                            fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((\"00\" + o[k]).substr((\"\" + o[k]).length)));\n                    return fmt;\n                }\n                return new Date(value).Format(\"yyyy-MM-dd hh:mm:ss\");\n            })\n    \n            // 2. 添加全局资源\n            //  添加注入组件时，是否利用console.log来通知的判断条件，也是组件实例属性\n            Vue.prototype.NOTICE = true;\n    \n    \n            // 3. 注入组件\n            //  注入组件，插件加载开始前提示\n            Vue.mixin({\n                created: function () {\n                    if (this.NOTICE)\n                        console.log(\"组件开始加载\")\n                },\n                methods: {\n                    test: function () {\n                        console.log(\"mixin test\");\n                    }\n                }\n            })\n    \n    \n            // 4. 添加实例方法\n            //  返回数字是输入数字的两倍，如果不是数字或者不能隐式转换为数字，则输出null\n            //  组件实例方法\n            Vue.prototype.doubleNumber = function (val) {\n                if (typeof val === 'number') {\n                    return val * 2;\n                } else if (!isNaN(Number(val))) {\n                    return Number(val) * 2;\n                } else {\n                    return null\n                }\n            }\n    \n            // 4. 添加实例方法\n            //  服务组，将实例方法整合到$service中，避免命名冲突\n            Vue.prototype.$service = {\n                //电话号码合法性检查\n                telNumberCheck: function (tel) {\n                    var pattern = /(^(([0\\+]\\d{2,3}-)?(0\\d{2,3})-)(\\d{7,8})(-(\\d{3,}))?$)|(^0{0,1}1[3|4|5|6|7|8|9][0-9]{9}$)/;\n                    return pattern.test(tel)\n                }\n            }\n        }\n    };",
    "render": "<h2><a id=\"Vue_0\"></a>Vue插件</h2>\n<h3><a id=\"1_3\"></a>1、概述</h3>\n<p>简单来说，插件就是指对Vue的功能的增强或补充。</p>\n<p>比如说，让你在每个单页面的组件里，都可以调用某个方法，或者共享使用某个变量，或者在某个方法之前执行一段代码等</p>\n<h3><a id=\"2_9\"></a>2、使用方法</h3>\n<p>总体流程应该是：</p>\n<p>【声明插件】——【写插件】——【注册插件】——【使用插件】</p>\n<p>写插件和声明插件是同步的，然后注册到Vue对象中（不用担心重复注册），最后在写Vue组件的时候使用写的插件</p>\n<h4><a id=\"_17\"></a><strong>声明插件</strong></h4>\n<p>先写一个js文件，这个js文件就是插件文件，里面的基本内容如下：</p>\n<pre><code>/*   说明：\n *   插件文件：service.js\n *   作者：王冬   QQ：20004604\n * */\nexport default {\n    install: function (Vue, options) {\n        // 添加的内容写在这个函数里面\n    }\n};\n</code></pre>\n<p>其中install的第一个参数Vue表示的是Vue的实例，第二个参数表示的是一些设置选项。</p>\n<p>Vue实例好理解，就是Vue对象。</p>\n<p>而options设置选项就是指，在调用这个插件时，可以传一个对象。</p>\n<p>例如这个对象有一个属性float，然后在写插件的一个方法/变量时，我需要输出一个数字，然后写一个if判断语句，</p>\n<p>假如options.float为true时，输出浮点数；</p>\n<p>假如为false或undefined（即没传参）时，输出为整数。</p>\n<p>具体怎么添加，之后再说。</p>\n<h4><a id=\"_45\"></a><strong>注册插件</strong></h4>\n<p>如果使用过Vue-router，就很好理解，通过import引入后，然后通过 <code>Vue.use(插件名)</code> 注册插件；</p>\n<p>例如，我们通常在main.js里引入各种东西，并且组件的根实例也在这里</p>\n<pre><code>//main.js\nimport Vue from 'vue'\nimport App from './App.vue'\n\n//关键是这两行\nimport service from './service.js'\nVue.use(service)\n\nnew Vue({\n    el: '#app',\n    render: (h) =&gt; h(App)\n})\n</code></pre>\n<p>如代码中注释所说，关键是通过import导入service文件，然后在创建根组件之前，让Vue对象通过use方法来注册插件service。</p>\n<p>通过这样简单的两步，就可以使用插件了。</p>\n<h3><a id=\"3_68\"></a>3、写插件、使用插件</h3>\n<p>按照官方文档，写插件有四种方法，先给出官方的代码：</p>\n<pre><code>//以下内容都是添加到上面install的函数里面的\n\n// 1. 添加全局方法或属性\nVue.myGlobalMethod = function () {\n    // 逻辑...\n}\n// 2. 添加全局资源\nVue.directive('my-directive', {\n    bind (el, binding, vnode, oldVnode) {\n        // 逻辑...\n    }\n    ...\n})\n// 3. 注入组件\nVue.mixin({\n    created: function () {\n        // 逻辑...\n    }\n    ...\n})\n// 4. 添加实例方法\nVue.prototype.$myMethod = function (options) {\n    // 逻辑...\n}\n</code></pre>\n<p>先给出最常用的：【4. 添加实例方法】的写法和使用方法</p>\n<h4><a id=\"31_99\"></a><strong>3.1【添加实例方法或属性】</strong></h4>\n<p>1、核心思想：</p>\n<pre><code>通过prototype来添加方法和属性。\n</code></pre>\n<p>2、写：</p>\n<pre><code>//让输出的数字翻倍，如果不是数字或者不能隐式转换为数字，则输出null\nVue.prototype.doubleNumber = function (val) {\n    if (typeof val === 'number') {\n        return val * 2;\n    } else if (!isNaN(Number(val))) {\n        return Number(val) * 2;\n    } else {\n        return null\n    }\n}\n</code></pre>\n<p>3、用：</p>\n<p>假设有这样一个组件：</p>\n<pre><code>&lt;template&gt;\n    &lt;div&gt;\n        {{num}}\n        &lt;button @click=&quot;double&quot;&gt;点击后让左边的数字翻倍&lt;/button&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n    export default{\n        data(){\n            return {\n                num: 1\n            }\n        },\n        methods: {\n            double: function () {\n                //这里的this.doubleNumber()方法就是上面写的组件里的方法\n                this.num = this.doubleNumber(this.num);\n            }\n        }\n    }\n&lt;/script&gt;\n</code></pre>\n<p>我们便可以通过点击button按钮，让num的值，在每次点击都翻倍了。</p>\n<p>4、假如添加的是属性：</p>\n<p>例如：</p>\n<pre><code>Vue.prototype.number = 1;\n</code></pre>\n<p>会发生什么事情呢？</p>\n<pre><code>1、不管是【按值传递类型】还是【按引用传递类型】，该变量都不会被不同组件所共享，更准确的说，假如有A、B两个组件。A组件里的number数值改变，B组件里的number数值是不会跟着改变的。因此不要想着引用这样一个变量，然后修改了A中的值，B里也自动跟着改变了；\n2、当组件里没有该属性时，调用时，显示的是通过插件获取的值；\n   当组件里有该属性时，调用时，显示的是组件里该属性的值；\n   由此而推，函数也是这样的，组件里的同名函数总是会覆盖插件提供的函数。\n</code></pre>\n<p>也就是说，当插件提供一个属性时，组件里没这个属性，就用插件的属性；组件有，就用组件自己的。</p>\n<h4><a id=\"32_165\"></a><strong>3.2【添加全局方法或属性】</strong></h4>\n<p>1、核心思想：</p>\n<p>就是给Vue对象添加一个属性。</p>\n<p>初次接触很容易和上面3.1弄混，实际上，3.1是给组件里使用的，而3.2是给Vue对象使用的。</p>\n<p>例如，假如添加一个方法test()，那么：</p>\n<pre><code>通过3.1添加，是在组件里，通过this.test()来调用\n\n通过3.2添加，是在外面，通过Vue实例，如Vue.test()来调用\n</code></pre>\n<p>2、写：</p>\n<pre><code>//放在哪里参考上面\nVue.test = function () {\n    alert(&quot;123&quot;)\n}\n</code></pre>\n<p>3、用：</p>\n<pre><code>//注意先导入Vue对象才能使用\nVue.test()\n</code></pre>\n<p>使用时会执行对应的方法，比如这里就是alert弹窗</p>\n<p>4、其他：</p>\n<p>别问我如果和Vue本身属性同名会发生什么事情，我没试过=.=</p>\n<h4><a id=\"33_198\"></a><strong>3.3【注入组件】</strong></h4>\n<p>1、核心思想：</p>\n<p>就像写Vue组件时，那样写，方法名保持一致，其会在执行组件对应的方法名之前执行。</p>\n<p>2、写：</p>\n<p>例如：</p>\n<pre><code>Vue.mixin({\n    created: function () {\n        console.log(&quot;组件开始加载&quot;)\n    }\n})\n</code></pre>\n<p>然后这里的代码会在每个组件（包括根组件）的created执行之前执行。</p>\n<p>可以自行在每个组件的created方法里写一段console.log来查看测试</p>\n<p>可以和【实例属性】配合使用，用于调试或者控制某些功能</p>\n<pre><code>// 注入组件\nVue.mixin({\n    created: function () {\n        if (this.NOTICE)\n            console.log(&quot;组件开始加载&quot;)\n    }\n})\n// 添加注入组件时，是否利用console.log来通知的判断条件\nVue.prototype.NOTICE = false;\n</code></pre>\n<p>【注入给非Vue实例本身就有的方法】：</p>\n<p>假如是写给例如methods属性的某个方法，例如以下注入：</p>\n<pre><code>Vue.mixin({\n    methods: {\n        test: function () {\n            console.log(&quot;mixin test&quot;);\n        }\n    }\n})\n</code></pre>\n<p>那么，组件里若本身有test方法，并 <strong>不会</strong> 先执行插件的test方法，再执行组件的test方法。</p>\n<p>而是只执行其中一个，并且优先执行组件本身的同名方法。这点需要注意</p>\n<p>3、用：</p>\n<p>不需要手动调用，在执行对应的方法时会被自动调用的（并且先调用插件里的，再调用组件本身的）</p>\n<p>4、其他：</p>\n<pre><code>1、如果同时有多个插件注入一个方法（例如created，那么会先执行先注入的那个方法，再依次执行后注入的，最后执行组件本身的）\n2、注意，像methods属性下的方法，并不会在组件注入后每个都执行，而是只执行一个，并且优先执行组件本身的。\n</code></pre>\n<h4><a id=\"34_257\"></a><strong>3.4【添加全局资源】</strong></h4>\n<p>1、核心思想：</p>\n<p>添加方法和正常添加方法类似，甚至几乎一样。</p>\n<p>可以添加【自定义指令】、【过滤器】、【过渡等】，这里以【过滤器】为例</p>\n<p>2、写：</p>\n<p>例如：</p>\n<pre><code>//时间格式化过滤器，输入内容是number或者Date对象，输出是YYYY-MM-DD HH-MM-SS\nVue.filter('formatTime', function (value) {\n    Date.prototype.Format = function (fmt) { //author: meizz\n        var o = {\n            &quot;M+&quot;: this.getMonth() + 1, //月份\n            &quot;d+&quot;: this.getDate(), //日\n            &quot;h+&quot;: this.getHours(), //小时\n            &quot;m+&quot;: this.getMinutes(), //分\n            &quot;s+&quot;: this.getSeconds(), //秒\n            &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), //季度\n            &quot;S&quot;: this.getMilliseconds() //毫秒\n        };\n        if (/(y+)/.test(fmt))\n            fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length));\n        for (var k in o)\n            if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt))\n                fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)));\n        return fmt;\n    }\n    return new Date(value).Format(&quot;yyyy-MM-dd hh:mm:ss&quot;);\n})\n</code></pre>\n<p>3、用：</p>\n<p>和正常使用一样用就行了，so easy。例如：</p>\n<pre><code>{{num|formatTime}}\n</code></pre>\n<p>4、其他：</p>\n<p>可以用这个找各种有意思的功能，作为插件写好，然后需要的地方导入就行，超级方便！</p>\n<h3><a id=\"4demo_301\"></a>4、示例demo</h3>\n<p>附一个有简单功能的示例demo，提供参考使用</p>\n<pre><code>/*  说明：\n *  插件demo，供学习使用\n *  本页面用于提供各种处理服务\n *  作者：王冬   QQ：20004604\n *  功能有：\n *  1、插件created执行时提示；\n *  2、\n * */\nexport default {\n    install: function (Vue, options) {\n        // 1. 添加全局方法或属性\n        // 略\n\n        // 2. 添加全局资源\n        //  时间格式化过滤器，输入内容是number或者Date对象，输出是YYYY-MM-DD HH-MM-SS\n        Vue.filter('formatTime', function (value) {\n            Date.prototype.Format = function (fmt) { //author: meizz\n                var o = {\n                    &quot;M+&quot;: this.getMonth() + 1, //月份\n                    &quot;d+&quot;: this.getDate(), //日\n                    &quot;h+&quot;: this.getHours(), //小时\n                    &quot;m+&quot;: this.getMinutes(), //分\n                    &quot;s+&quot;: this.getSeconds(), //秒\n                    &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), //季度\n                    &quot;S&quot;: this.getMilliseconds() //毫秒\n                };\n                if (/(y+)/.test(fmt))\n                    fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length));\n                for (var k in o)\n                    if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt))\n                        fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)));\n                return fmt;\n            }\n            return new Date(value).Format(&quot;yyyy-MM-dd hh:mm:ss&quot;);\n        })\n\n        // 2. 添加全局资源\n        //  添加注入组件时，是否利用console.log来通知的判断条件，也是组件实例属性\n        Vue.prototype.NOTICE = true;\n\n\n        // 3. 注入组件\n        //  注入组件，插件加载开始前提示\n        Vue.mixin({\n            created: function () {\n                if (this.NOTICE)\n                    console.log(&quot;组件开始加载&quot;)\n            },\n            methods: {\n                test: function () {\n                    console.log(&quot;mixin test&quot;);\n                }\n            }\n        })\n\n\n        // 4. 添加实例方法\n        //  返回数字是输入数字的两倍，如果不是数字或者不能隐式转换为数字，则输出null\n        //  组件实例方法\n        Vue.prototype.doubleNumber = function (val) {\n            if (typeof val === 'number') {\n                return val * 2;\n            } else if (!isNaN(Number(val))) {\n                return Number(val) * 2;\n            } else {\n                return null\n            }\n        }\n\n        // 4. 添加实例方法\n        //  服务组，将实例方法整合到$service中，避免命名冲突\n        Vue.prototype.$service = {\n            //电话号码合法性检查\n            telNumberCheck: function (tel) {\n                var pattern = /(^(([0\\+]\\d{2,3}-)?(0\\d{2,3})-)(\\d{7,8})(-(\\d{3,}))?$)|(^0{0,1}1[3|4|5|6|7|8|9][0-9]{9}$)/;\n                return pattern.test(tel)\n            }\n        }\n    }\n};</code></pre>\n",
    "url": "/notes/006/2BA09623"
}